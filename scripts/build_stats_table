#! /usr/bin/env python

"""Regenerate the stats table in the hstlc database, which stores
statistics for every lightcurve (composite and individual).
"""

import argparse
import logging
import multiprocessing
import os

from astropy.io import fits
import lightcurve
import numpy as np
from scipy.stats.stats import pearsonr

from lightcurve_pipeline.utils.utils import insert_or_update
from lightcurve_pipeline.utils.utils import SETTINGS
from lightcurve_pipeline.utils.utils import setup_logging
from lightcurve_pipeline.database.database_interface import engine
from lightcurve_pipeline.database.database_interface import session
from lightcurve_pipeline.database.database_interface import Stats
from lightcurve_pipeline.database.database_interface import Outputs
from lightcurve_pipeline.database.update_database import update_stats_table

# -----------------------------------------------------------------------------

def get_lightcurves(product_type):
    """Queries the Outputs table to build a list of lightcurves to get
    stats from.

    Returns
    -------
    lightcurves : list
        A list of paths to lightcurve products.
    """

    results = session.query(Outputs).all()
    individual_lightcurves = set([os.path.join(result.individual_path, result.individual_filename) for result in results])
    composite_lightcurves = set([os.path.join(result.composite_path, result.composite_filename) for result in results if result.composite_filename != None])

    if product_type == 'individual':
        lightcurves = individual_lightcurves
    elif product_type == 'composite':
        lightcurves = composite_lightcurves
    elif prodcut_type == 'both':
        lightcurves = individual_lightcurves | composite_lightcurves

    return lightcurves

# -----------------------------------------------------------------------------

def get_stats(dataset):
    """Gathers various statistics for the given lightcurve product.

    Parameters
    ----------
    dataset : string
        The path to the lightcurve product.

    Returns
    -------
    stats_dict : dictionary
        A dictionary whose keys are column names of the Stats table and
        whose values are the corresponding statistics.
    """

    stats_dict = {}
    stats_dict['lightcurve_path'] = os.path.dirname(dataset)
    stats_dict['lightcurve_filename'] = os.path.basename(dataset)

    # Open lightcurve and extract information
    hdulist = fits.open(dataset, mode='readonly')
    counts = hdulist[1].data.counts
    mjd = hdulist[1].data.mjd
    stats_dict['total'] = int(np.sum(counts))
    stats_dict['mean'] = float(np.mean(counts))
    stats_dict['mu'] = np.sqrt(stats_dict['mean'])
    stats_dict['stdev'] = float(np.std(counts))
    stats_dict['poisson_factor'] = stats_dict['mu'] / stats_dict['stdev']
    pearson_results = pearsonr(mjd, counts)
    stats_dict['pearson_r'] = float(pearson_results[0])
    stats_dict['pearson_p'] = float(pearson_results[1])

    if np.isnan(stats_dict['pearson_r']):
        stats_dict['pearson_r'] = 0.0

    return stats_dict

# -----------------------------------------------------------------------------

def parse_args():
    """Parse command line arguments.

    Returns
    -------
    args : argparse object
        An argparse object containing the arguments.
    """

    product_help = ('The type of output products to process.  Can be '
        '"individual", "composite", or "both".')

    parser = argparse.ArgumentParser()
    parser.add_argument('product_type', action='store', type=str, help=product_help)
    args = parser.parse_args()

    # Make sure the argument is a valid option
    valid_options = ['individual', 'composite', 'both']
    explanation = '{} is not a valid option.  Please choose "individual", "composite", or "both".'.format(args.product_type)
    assert args.product_type in valid_options, explanation

    return args

# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

if __name__ == '__main__':

    module = os.path.basename(__file__).strip('.py')
    setup_logging(module)

    args = parse_args()

    # Query the outputs table for a list of lightcurves
    lightcurves = get_lightcurves(args.product_type)

    # For each lightcurve, compute statistics and update the database
    logging.info('{} datasets to process'.format(len(lightcurves)))
    for dataset in lightcurves:
        logging.info('Processing {}'.format(dataset))
        stats_dict = get_stats(dataset)
        update_stats_table(stats_dict, dataset)

    logging.info('Processing complete')
