#! /usr/bin/env python

"""
Reset all tables in the database.
"""

from __future__ import print_function

from collections import Counter
import glob
import itertools
import multiprocessing as mp
import os

from astropy.io import fits
from astropy.table import Table
import bokeh
from bokeh import charts
from bokeh.io import gridplot
from bokeh.plotting import figure
from bokeh.embed import components
from bokeh import palettes
import numpy as np
import scipy
from scipy.signal import lombscargle
from sqlalchemy.engine import create_engine

import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as plt

#import seaborn as sns
#sns.set(style="dark")

from lightcurve_pipeline.utils.utils import SETTINGS
from lightcurve_pipeline.utils.utils import set_permissions
from lightcurve_pipeline.database.database_interface import engine
from lightcurve_pipeline.database.database_interface import session
from lightcurve_pipeline.database.database_interface import Metadata
from lightcurve_pipeline.database.database_interface import Stats

#-------------------------------------------------------------------------------

def bar_opt_elem():
    """
    Create a bar chart showing the number of composite lightcurves
    for each COS & STIS optical element
    """

    # Query for data
    query = session.query(Metadata.instrume, Metadata.opt_elem).all()
    instrumes = [result[0] for result in query]
    opt_elems = [result[1] for result in query]
    opt_elems_set = sorted(list(set(opt_elems)))

    # Initialize dictionaries that store all optical elements
    cos_dict, stis_dict = {}, {}
    for opt_elem in opt_elems_set:
        cos_dict[opt_elem] = 0
        stis_dict[opt_elem] = 0

    # Count number of opt_elems
    for instrument, opt_elem in zip(instrumes, opt_elems):
        if instrument == 'COS':
            cos_dict[opt_elem] += 1
        elif instrument == 'STIS':
            stis_dict[opt_elem] += 1

    # Determine plotting values
    cat = list(opt_elems_set)
    xyvalues = OrderedDict()
    xyvalues['COS'] = [cos_dict[opt_elem] for opt_elem in opt_elems_set]
    xyvalues['STIS'] = [stis_dict[opt_elem] for opt_elem in opt_elems_set]

    # Make plots
    bar = charts.Bar(xyvalues,
        cat,
        xlabel="Optical Element",
        ylabel="# of Lightcurves",
        stacked=True,
        legend = "top_right")
    bar.background_fill = "#cccccc"
    bar.outline_line_color = 'black'
    charts.output_file(os.path.join(SETTINGS['plot_dir'], "opt_elem.html"))
    #charts.show(bar)

#-------------------------------------------------------------------------------

def histogram_exptime():
    print("Starting the histogram")

    data_dir = SETTINGS['composite_dir']
    #plot_dir = SETTINGS['plot']
    data_dir = '/Volumes/papers/hst13902/outputs/composite/'

    exptime_data = {}
    for dataset in glob.glob(os.path.join(data_dir, '*.fits')):
        print(dataset)
        with fits.open(dataset) as hdu:
            targname = os.path.split(dataset)[-1].split('_')[0] #hdu[0].header['targname']
            exptime = hdu[0].header['EXPTIME']

            if targname in exptime_data:
                exptime_data[targname] += exptime
            else:
                exptime_data[targname] = exptime

    charts.output_file(os.path.join(SETTINGS['plot_dir'], "exptime_histogram.html"))

    times = np.array(exptime_data.values())
    names = np.array(exptime_data.keys())
    indx = np.argsort(times)

    times = list(times[indx])[::-1][:30]
    names = list(names[indx])[::-1][:30]

    bar = charts.Bar(times,
                     cat=names,
                     xlabel='Target',
                     ylabel='Exptime (s)',
                     width=700,
                     height=400,
                     title='Cumulative Exptime per Target')

    bar.background_fill = "#cccccc"
    bar.outline_line_color = 'black'

    # change just some things about the x-grid
    #bar.xgrid.grid_line_color = None

    # change just some things about the y-grid
    #bar.ygrid.band_fill_alpha = 0.1
    #bar.ygrid.band_fill_color = "navy"

    #bar.toolbar_location = None

    #charts.show(bar)

    script, div = components(bar)

    print(div)
    print()
    print(script)

#-------------------------------------------------------------------------------

def piechart_config():
    print("Starting the piechart")

    data_dir = SETTINGS['composite_dir']
    #plot_dir = SETTINGS['plot']

    configs = {}
    for dataset in glob.glob(os.path.join(data_dir, '*.fits')):
        #with fits.open(dataset) as hdu:
        #    exptime = hdu[0].header['TOTTIME'] #hdu[0].header['EXPTIME']

        instrument = os.path.split(dataset)[1].split('_')[1]
        grating = os.path.split(dataset)[1].split('_')[2]
        cenwave = os.path.split(dataset)[1].split('_')[3]

        if not instrument in configs:
            configs[instrument] = [grating+'/'+cenwave]
        else:
            configs[instrument].append(grating+'/'+cenwave)

        print(instrument, grating, cenwave)

    #-- COS FUV
    settings = Counter(configs['FUV'])
    charts.output_file("pie_config_cos_fuv.html")

    plot = charts.Donut(settings.values(),
                        settings.keys(),
                        width=1200,
                        height=600,
                        title='COS FUV breakdown')
    #charts.show(plot)
    #print(settings)

    '''
    #-- COS NUV
    settings = Counter(configs['NUV'])
    charts.output_file("pie_config_cos_nuv.html")

    plot = charts.Donut(settings.values(),
                        settings.keys(),
                        width=1200,
                        height=600,
                        title='COS NUV breakdown')
    charts.show(plot)
    print(settings)
    '''

    #-- STIS FUV
    settings = Counter(configs['FUV-MAMA'])
    charts.output_file(os.path.join(SETTINGS['plot_dir'], "pie_config_stis_fuv.html"))

    plot = charts.Donut(settings.values(),
                        settings.keys(),
                        width=1200,
                        height=600,
                        title='STIS FUV breakdown')
    #charts.show(plot)
    #print(settings)

    #-- STIS NUV
    settings = Counter(configs['NUV-MAMA'])
    charts.output_file(os.path.join(SETTINGS['plot_dir'], "pie_config_stis_nuv.html"))

    plot = charts.Donut(settings.values(),
                        settings.keys(),
                        width=1200,
                        height=600,
                        title='STIS NUV breakdown')
    #charts.show(plot)
    #print(settings)

#-------------------------------------------------------------------------------

def simple_stat_plots():

    query = session.query(Stats.total, Stats.stdev).all()

    counts = []
    std = []
    for row in query:
        counts.append(row['total'])
        std.append(row['stdev'])


#-------------------------------------------------------------------------------

def dataset_dashboard(filename, plot_file=''):
    if not plot_file:
        plot_file = filename.replace('.fits', '.html')
        print(plot_file)
    if os.path.exists(plot_file):
        os.remove(plot_file)

    bokeh.io.output_file(plot_file)
    TOOLS = "pan,wheel_zoom,box_zoom,reset,resize,box_select,lasso_select,save"

    with fits.open(filename) as hdu:
        source = bokeh.models.ColumnDataSource(data={col : hdu[1].data[col] for col in hdu[1].data.names})

        endless_colors = itertools.cycle(palettes.Spectral6)
        colors = [endless_colors.next() for i in np.unique(hdu[1].data['dataset'])]

        dset_counts = Counter(hdu[1].data['dataset'])
        repeats = [dset_counts[key] for key in sorted(dset_counts.keys())]

        colors = np.repeat(colors, repeats)

        axes = []
        for key in ['gross', 'net', 'flux', 'error', 'background']:
            if len(axes) == 0:
                axes.append(figure(tools=TOOLS, plot_width=900, plot_height=350, title=key, toolbar_location="right"))
            else:
                axes.append(figure(tools=TOOLS, x_range=axes[0].x_range, plot_width=900, plot_height=350, title=key, toolbar_location="right"))
            axes[-1].circle('mjd',
                            key,
                            source=source,
                            size=12,
                            color=colors,
                            fill_alpha=1)


    # put all the plots in a grid layout
    p = bokeh.io.vplot(*axes)

    charts.save(obj=p, filename=plot_file)
    charts.reset_output()
    del p

#-------------------------------------------------------------------------------

def process_periodograms():
    """
    Create periodograms for every dataset (individual and composite)
    using multiprocessing
    """

    datasets = glob.glob(os.path.join(SETTINGS['outputs_dir'], '*/*curve.fits'))
    plt.rcParams['axes.formatter.useoffset'] = False

    print('Making periodograms for {} datasets over {} cores'.format(len(datasets), SETTINGS['num_cores']))
    pool = mp.Pool(processes=SETTINGS['num_cores'])
    pool.map(periodogram, datasets)
    pool.close()
    pool.join()
    periodogram(datasets)

#-------------------------------------------------------------------------------

def periodogram(dataset):
    """
    Create a periodgram for the given dataset.
    """

    print('Making periodogram for {}'.format(dataset))

    # Get the data
    hdulist = fits.open(dataset, mode='readonly')
    counts = hdulist[1].data['net']
    times = hdulist[1].data['mjd']

    if max(counts) > 0:

        # Make sure the byte-order is native
        counts = counts.byteswap().newbyteorder()
        times = times.byteswap().newbyteorder()

        # Define frequency space (in days)
        short_freq = (hdulist[0].header['STEPSIZE'] / (60. * 60. * 24.)) # Step size
        med_freq = (10. / (60. * 24.)) # 10 minutes
        long_freq = 1. / 24. # 1 hour
        max_freq = 10. / 24. # 10 hours

        # Build frequency space
        short_periods = np.linspace(short_freq, med_freq, len(times))
        med_periods = np.linspace(med_freq, long_freq, len(times))
        long_periods = np.linspace(long_freq, max_freq, len(times))
        short_ang_freqs = 2 * np.pi / short_periods
        med_ang_freqs = 2 * np.pi / med_periods
        long_ang_freqs = 2 * np.pi / long_periods

        # Find lomb-scargle power
        short_power = lombscargle(np.asarray(times), np.asarray(counts) - np.asarray(counts).mean(), short_ang_freqs)
        med_power = lombscargle(np.asarray(times), np.asarray(counts) - np.asarray(counts).mean(), med_ang_freqs)
        long_power = lombscargle(np.asarray(times), np.asarray(counts) - np.asarray(counts).mean(), long_ang_freqs)
        short_power *= 2 / (len(times) * np.asarray(counts).std() ** 2)
        med_power *= 2 / (len(times) * np.asarray(counts).std() ** 2)
        long_power *= 2 / (len(times) * np.asarray(counts).std() ** 2)

        # Find local maxima
        short_maxima = scipy.signal.argrelextrema(data=short_power, comparator=np.greater, order=1)[0]
        med_maxima = scipy.signal.argrelextrema(data=med_power, comparator=np.greater, order=1)[0]
        long_maxima = scipy.signal.argrelextrema(data=long_power, comparator=np.greater, order=1)[0]

        # Find mean and standard deviation for each frequency space
        short_mean = np.mean(short_power)
        med_mean = np.mean(med_power)
        long_mean = np.mean(long_power)
        short_std = np.std(short_power)
        med_std = np.std(med_power)
        long_std = np.std(long_power)
        short_three_sigma = short_mean + (3 * short_std)
        med_three_sigma = med_mean + (3 * med_std)
        long_three_sigma = long_mean + (3 * long_std)

        # Isolate the maxima above three sigma
        short_above_three_sigma = np.where(short_power > short_three_sigma)[0]
        med_above_three_sigma = np.where(med_power > med_three_sigma)[0]
        long_above_three_sigma = np.where(long_power > long_three_sigma)[0]

        # Find the peaks above three sigma
        short_significant_indices = [index for index in short_maxima if index in short_above_three_sigma]
        med_significant_indices = [index for index in med_maxima if index in med_above_three_sigma]
        long_significant_indices = [index for index in long_maxima if index in long_above_three_sigma]
        short_significant_periods = short_periods[short_significant_indices]
        med_significant_periods = med_periods[med_significant_indices]
        long_significant_periods = long_periods[long_significant_indices]

        # Make plot
        fig = plt.figure(figsize=(10, 8))
        ax1 = fig.add_subplot(411)
        ax2 = fig.add_subplot(412)
        ax3 = fig.add_subplot(413)
        ax4 = fig.add_subplot(414)
        ax1.minorticks_on()

        # Top panel - the data
        ax1.plot(times, counts, 'b+')
        ax1.set(xlabel='MJD', ylabel='Net')

        # 2nd panel - short frequency space
        ax2.plot(short_periods, short_power)
        ax2.axhline(short_mean, color='r', linestyle='-')
        ax2.axhline(short_three_sigma, color='g', linestyle='-')
        for period in short_significant_periods:
            ax2.axvline(period, color='k', linestyle='--')
        ax2.set(xlim=(short_freq, med_freq), title='Short Frequency Space')

        # 3rd panal - medium frequency space
        ax3.plot(med_periods, med_power)
        ax3.axhline(med_mean, color='r', linestyle='-')
        ax3.axhline(med_three_sigma, color='g', linestyle='-')
        for period in med_significant_periods:
            ax2.axvline(period, color='k', linestyle='--')
        ax3.set(xlim=(med_freq, long_freq), ylabel='Lomb-Scargle Power', title='Medium Frequency Space')

        # bottom panel - long frequency space
        ax4.plot(long_periods, long_power)
        ax4.axhline(long_mean, color='r', linestyle='-')
        ax4.axhline(long_three_sigma, color='g', linestyle='-')
        for period in long_significant_periods:
            ax2.axvline(period, color='k', linestyle='--')
        ax4.set(xlim=(long_freq, max_freq), xlabel='Period (Days)', title='Long Frequency Space')

        # Save the plot
        fig.tight_layout()
        filename = '{}_periodogram.png'.format(os.path.basename(dataset).split('_curve.fits')[0])
        save_loc = os.path.join(SETTINGS['plot_dir'], filename)
        plt.savefig(save_loc)
        plt.close()
        set_permissions(save_loc)

#-------------------------------------------------------------------------------

def plot_dataset(filename, plot_file=''):
    path, name = os.path.split(filename)

    if not plot_file:
        plot_file = name.replace('.fits', '.html')
    if os.path.exists(plot_file):
        os.remove(plot_file)

    TOOLS = "pan,wheel_zoom,box_zoom,box_select,lasso_select,reset,resize,save"


    p = figure(tools=TOOLS, toolbar_location="above", logo="grey", plot_width=700)
    #p.title = "{} LightCurve".format(name)
    p.background_fill= "#cccccc"

    with fits.open(filename) as hdu:
        p.circle(hdu[1].data['MJD'],
                 hdu[1].data['FLUX'],
                 size=12,
                 line_color="black",
                 fill_alpha=0.8)


    p.xaxis.axis_label="Time (MJD)"
    p.yaxis.axis_label="Net (cnts/sec)"
    p.grid.grid_line_color="white"

    charts.save(obj=p, filename=plot_file)
    charts.reset_output()
    del p

    #charts.show(p)

    #script, div = components(p)

    #print(div)
    #print()
    #print(script)
#-------------------------------------------------------------------------------

def plot_dataset_static(filename, plot_file=''):
    if not plot_file:
        plot_file = filename.replace('.fits', '.png')
        print(plot_file)
    if os.path.exists(plot_file):
        os.remove(plot_file)

    fig = plt.figure(figsize=(10, 1))
    ax = fig.add_subplot(1, 1, 1)

    with fits.open(filename) as hdu:
        indx = np.argsort(hdu[1].data['MJD'])
        xvals = np.arange(len(hdu[1].data['MJD']))
        yvals = hdu[1].data['FLUX']

        try:
            colors = hdu[1].data['dataset'][indx]
        except KeyError:
            colors = np.ones(xvals.shape)

        ax.scatter(xvals,
                   yvals[indx],
                   c=colors,
                   marker='o')

    ax.set_xlim(0, xvals.max())
    ax.set_ylim(yvals[indx].min(), yvals[indx].max())
    fig.savefig(plot_file, bbox_inches='tight')
    plt.close(fig)
    del fig

#-------------------------------------------------------------------------------

def make_all_plots():

    pool = mp.Pool(processes=10)

    data_dir = SETTINGS['composite_dir']
    datasets = glob.glob(os.path.join(data_dir, '*.fits'))
    print("Matplotlib")
    pool.map(plot_dataset_static, datasets)
    print("bokeh")
    pool.map(dataset_dashboard, datasets)

#-------------------------------------------------------------------------------

def make_exploratory_table(dataset_list, table_name):
    info = []
    for dataset in dataset_list:
        path, name = os.path.split(dataset)

        with fits.open(dataset) as hdu:
            exptime = hdu[0].header['EXPTIME']

        targname = os.path.split(dataset)[1].split('_')[0]
        instrument = os.path.split(dataset)[1].split('_')[1]
        grating = os.path.split(dataset)[1].split('_')[2]
        cenwave = os.path.split(dataset)[1].split('_')[3]

        results = connection.execute("""SELECT total,mean,poisson_factor,pearson_r,pearson_p FROM stats WHERE lightcurve_filename='{}';""".format(name))
        total, mean, poisson_f, pearson_r, pearson_p = results.fetchall()[0]

        print(targname, instrument, grating, cenwave, poisson_f)

        plot_name = dataset.replace('.fits', '.html')
        plot_name_static = dataset.replace('.fits', '.png')

        plot_html = """<a href="{}" target="_blank"><img width="400" src="{}"><a>""".format(plot_name, plot_name_static)
        new_row = (targname, plot_html, instrument, grating, cenwave, exptime, total, mean, poisson_f, pearson_r, pearson_p, dataset)
        info.append(new_row)

    out_tab = Table(rows=info,
                    names=('target', 'plot', 'instrument', 'grating', 'cenwave', 'exptime', 'total', 'mean', 'poisson_f', 'pearson_r', 'pearson_p', 'filename'))
    out_tab.write(table_name, format='jsviewer')

    os.system("""sed -i '' "s/&lt;/</g" {}""".format(table_name))
    os.system("""sed -i '' "s/&gt;/>/g" {}""".format(table_name))

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------

if __name__ == "__main__":

    print("Making plots for HSTLC")
    make_all_plots()

    process_periodograms()

    engine = create_engine(SETTINGS['db_connection_string'])
    connection = engine.connect()

    #-- find interesting datasets
    results = connection.execute("""SELECT lightcurve_path,lightcurve_filename
                                            FROM stats
                                                WHERE poisson_factor IS NOT NULL
                                                    AND poisson_factor>=1.2
                                                    AND lightcurve_path LIKE '%%composite%%';""")
    interesting_datasets = [os.path.join(item[0], item[1]) for item in results.fetchall()]
    make_exploratory_table(interesting_datasets, os.path.join(SETTINGS['plot_dir'], 'interesting_hstlc.html'))

    #-- find interesting datasets
    results = connection.execute("""SELECT lightcurve_path,lightcurve_filename
                                            FROM stats
                                                WHERE poisson_factor IS NOT NULL
                                                    AND poisson_factor<1.2
                                                    AND lightcurve_path LIKE '%%composite%%';""")
    boring_datasets = [os.path.join(item[0], item[1]) for item in results.fetchall()]
    make_exploratory_table(boring_datasets, os.path.join(SETTINGS['plot_dir'], 'boring_hstlc.html'))

    #-- find NULL
    results = connection.execute("""SELECT lightcurve_path,lightcurve_filename
                                            FROM stats
                                                WHERE poisson_factor IS NULL
                                                    AND lightcurve_path LIKE '%%composite%%';""")
    null_datasets = [os.path.join(item[0], item[1]) for item in results.fetchall()]
    make_exploratory_table(null_datasets, os.path.join(SETTINGS['plot_dir'], 'null_hstlc.html'))


    #histogram_exptime()
    #piechart_config()
    #bar_opt_elem
    #plot_dataset('/grp/hst/hstlc/hst13902/outputs/composite/V4046SGR_FUV_G130M_1300_curve.fits', 'example_flare.html')
    #plot_dataset('/grp/hst/hstlc/hst13902/outputs/composite/IR-COM_FUV_G140L_1105_curve.fits', 'example_transit.html')
